import type { InfraGraph, InfraNode, IaCFramework } from '@/types/infrastructure';

// Cost estimates per resource type (monthly in USD)
const resourceCosts: Record<string, { base: number; description: string }> = {
  'vpc': { base: 0, description: 'No cost' },
  'subnet': { base: 0, description: 'No cost' },
  'internet-gateway': { base: 0, description: 'No cost (data transfer charged separately)' },
  'nat-gateway': { base: 32.85, description: '$0.045/hr + data processing' },
  'ec2': { base: 7.59, description: 't3.micro - $0.0104/hr' },
  'rds': { base: 12.41, description: 'db.t3.micro - $0.017/hr' },
  'alb': { base: 16.43, description: '$0.0225/hr + LCU charges' },
  's3': { base: 0.023, description: '$0.023/GB (first 50TB)' },
  'lambda': { base: 0, description: 'Pay per invocation' },
  'security-group': { base: 0, description: 'No cost' },
  'iam-role': { base: 0, description: 'No cost' },
  'cloudfront': { base: 0, description: 'Pay per request + data transfer' },
  'api-gateway': { base: 0, description: '$3.50 per million API calls' },
  'dynamodb': { base: 0, description: 'Pay per request (on-demand)' },
  'sqs': { base: 0, description: 'First 1M requests free' },
  'sns': { base: 0, description: 'First 1M requests free' },
  'elasticache': { base: 12.41, description: 'cache.t3.micro' },
  'route-table': { base: 0, description: 'No cost' },
};

export function estimateMonthlyCost(graph: InfraGraph): { total: number; breakdown: { type: string; count: number; cost: number; description: string }[] } {
  const counts: Record<string, number> = {};
  
  graph.nodes.forEach(node => {
    counts[node.type] = (counts[node.type] || 0) + 1;
  });

  const breakdown = Object.entries(counts).map(([type, count]) => {
    const costInfo = resourceCosts[type] || { base: 0, description: 'Unknown' };
    return {
      type,
      count,
      cost: costInfo.base * count,
      description: costInfo.description,
    };
  });

  const total = breakdown.reduce((sum, item) => sum + item.cost, 0);

  return { total, breakdown };
}

// Terraform generation
function generateTerraform(graph: InfraGraph): string {
  const lines: string[] = [
    '# Generated by InfraVizAI',
    `# Infrastructure: ${graph.metadata.name}`,
    `# Region: ${graph.metadata.region}`,
    `# Generated: ${new Date().toISOString()}`,
    '',
    'terraform {',
    '  required_providers {',
    '    aws = {',
    '      source  = "hashicorp/aws"',
    '      version = "~> 5.0"',
    '    }',
    '  }',
    '}',
    '',
    'provider "aws" {',
    `  region = "${graph.metadata.region}"`,
    '}',
    '',
  ];

  // Group nodes by type for organized output
  const nodesByType: Record<string, InfraNode[]> = {};
  graph.nodes.forEach(node => {
    if (!nodesByType[node.type]) nodesByType[node.type] = [];
    nodesByType[node.type].push(node);
  });

  // Generate VPC first
  if (nodesByType['vpc']) {
    nodesByType['vpc'].forEach(node => {
      const cidr = node.properties.cidr || '10.0.0.0/16';
      lines.push(
        `resource "aws_vpc" "${node.id}" {`,
        `  cidr_block           = "${cidr}"`,
        '  enable_dns_hostnames = true',
        '  enable_dns_support   = true',
        '',
        '  tags = {',
        `    Name = "${node.label}"`,
        '  }',
        '}',
        ''
      );
    });
  }

  // Internet Gateway
  if (nodesByType['internet-gateway']) {
    nodesByType['internet-gateway'].forEach(node => {
      const vpcRef = nodesByType['vpc']?.[0]?.id || 'main_vpc';
      lines.push(
        `resource "aws_internet_gateway" "${node.id}" {`,
        `  vpc_id = aws_vpc.${vpcRef}.id`,
        '',
        '  tags = {',
        `    Name = "${node.label}"`,
        '  }',
        '}',
        ''
      );
    });
  }

  // Subnets
  if (nodesByType['subnet']) {
    nodesByType['subnet'].forEach((node, index) => {
      const vpcRef = nodesByType['vpc']?.[0]?.id || 'main_vpc';
      const cidr = node.properties.cidr || `10.0.${index + 1}.0/24`;
      const isPublic = node.properties.isPublic !== false;
      const az = ['a', 'b', 'c'][index % 3];
      lines.push(
        `resource "aws_subnet" "${node.id}" {`,
        `  vpc_id                  = aws_vpc.${vpcRef}.id`,
        `  cidr_block              = "${cidr}"`,
        `  availability_zone       = "${graph.metadata.region}${az}"`,
        `  map_public_ip_on_launch = ${isPublic}`,
        '',
        '  tags = {',
        `    Name = "${node.label}"`,
        '  }',
        '}',
        ''
      );
    });
  }

  // Security Groups
  if (nodesByType['security-group']) {
    nodesByType['security-group'].forEach(node => {
      const vpcRef = nodesByType['vpc']?.[0]?.id || 'main_vpc';
      lines.push(
        `resource "aws_security_group" "${node.id}" {`,
        `  name        = "${node.label.toLowerCase().replace(/\s+/g, '-')}"`,
        `  description = "Security group for ${node.label}"`,
        `  vpc_id      = aws_vpc.${vpcRef}.id`,
        '',
        '  ingress {',
        '    from_port   = 443',
        '    to_port     = 443',
        '    protocol    = "tcp"',
        '    cidr_blocks = ["0.0.0.0/0"]',
        '  }',
        '',
        '  egress {',
        '    from_port   = 0',
        '    to_port     = 0',
        '    protocol    = "-1"',
        '    cidr_blocks = ["0.0.0.0/0"]',
        '  }',
        '',
        '  tags = {',
        `    Name = "${node.label}"`,
        '  }',
        '}',
        ''
      );
    });
  }

  // EC2 Instances
  if (nodesByType['ec2']) {
    nodesByType['ec2'].forEach(node => {
      const instanceType = node.properties.instanceType || 't3.micro';
      const subnetRef = nodesByType['subnet']?.[0]?.id;
      const sgRef = nodesByType['security-group']?.[0]?.id;
      lines.push(
        `resource "aws_instance" "${node.id}" {`,
        '  ami           = "ami-0c55b159cbfafe1f0"  # Amazon Linux 2',
        `  instance_type = "${instanceType}"`,
        subnetRef ? `  subnet_id     = aws_subnet.${subnetRef}.id` : '',
        sgRef ? `  vpc_security_group_ids = [aws_security_group.${sgRef}.id]` : '',
        '',
        '  tags = {',
        `    Name = "${node.label}"`,
        '  }',
        '}',
        ''
      );
    });
  }

  // RDS
  if (nodesByType['rds']) {
    nodesByType['rds'].forEach(node => {
      const instanceClass = node.properties.instanceType || 'db.t3.micro';
      const encrypted = node.properties.encrypted !== false;
      const sgRef = nodesByType['security-group']?.[0]?.id;
      lines.push(
        `resource "aws_db_instance" "${node.id}" {`,
        '  identifier           = "' + node.id + '"',
        `  instance_class       = "${instanceClass}"`,
        '  allocated_storage    = 20',
        '  engine               = "postgres"',
        '  engine_version       = "15"',
        '  username             = "admin"',
        '  password             = "CHANGE_ME_IN_SECRETS"',
        '  skip_final_snapshot  = true',
        `  storage_encrypted    = ${encrypted}`,
        sgRef ? `  vpc_security_group_ids = [aws_security_group.${sgRef}.id]` : '',
        '',
        '  tags = {',
        `    Name = "${node.label}"`,
        '  }',
        '}',
        ''
      );
    });
  }

  // ALB
  if (nodesByType['alb']) {
    nodesByType['alb'].forEach(node => {
      const subnets = nodesByType['subnet']?.map(s => `aws_subnet.${s.id}.id`) || [];
      const sgRef = nodesByType['security-group']?.[0]?.id;
      lines.push(
        `resource "aws_lb" "${node.id}" {`,
        `  name               = "${node.id}"`,
        '  internal           = false',
        '  load_balancer_type = "application"',
        sgRef ? `  security_groups    = [aws_security_group.${sgRef}.id]` : '',
        subnets.length > 0 ? `  subnets            = [${subnets.join(', ')}]` : '',
        '',
        '  tags = {',
        `    Name = "${node.label}"`,
        '  }',
        '}',
        ''
      );
    });
  }

  // S3
  if (nodesByType['s3']) {
    nodesByType['s3'].forEach(node => {
      const encrypted = node.properties.encrypted !== false;
      lines.push(
        `resource "aws_s3_bucket" "${node.id}" {`,
        `  bucket = "${node.id}-bucket"`,
        '',
        '  tags = {',
        `    Name = "${node.label}"`,
        '  }',
        '}',
        ''
      );
      if (encrypted) {
        lines.push(
          `resource "aws_s3_bucket_server_side_encryption_configuration" "${node.id}_encryption" {`,
          `  bucket = aws_s3_bucket.${node.id}.id`,
          '',
          '  rule {',
          '    apply_server_side_encryption_by_default {',
          '      sse_algorithm = "AES256"',
          '    }',
          '  }',
          '}',
          ''
        );
      }
    });
  }

  // Lambda
  if (nodesByType['lambda']) {
    const roleRef = nodesByType['iam-role']?.[0]?.id || 'lambda_role';
    nodesByType['lambda'].forEach(node => {
      lines.push(
        `resource "aws_lambda_function" "${node.id}" {`,
        `  function_name = "${node.id}"`,
        '  runtime       = "nodejs18.x"',
        '  handler       = "index.handler"',
        '  filename      = "lambda.zip"  # Placeholder',
        `  role          = aws_iam_role.${roleRef}.arn`,
        '',
        '  tags = {',
        `    Name = "${node.label}"`,
        '  }',
        '}',
        ''
      );
    });
  }

  // IAM Role
  if (nodesByType['iam-role']) {
    nodesByType['iam-role'].forEach(node => {
      lines.push(
        `resource "aws_iam_role" "${node.id}" {`,
        `  name = "${node.id}"`,
        '',
        '  assume_role_policy = jsonencode({',
        '    Version = "2012-10-17"',
        '    Statement = [{',
        '      Action = "sts:AssumeRole"',
        '      Effect = "Allow"',
        '      Principal = {',
        '        Service = "lambda.amazonaws.com"',
        '      }',
        '    }]',
        '  })',
        '',
        '  tags = {',
        `    Name = "${node.label}"`,
        '  }',
        '}',
        ''
      );
    });
  }

  return lines.filter(l => l !== undefined).join('\n');
}

// CloudFormation generation
function generateCloudFormation(graph: InfraGraph): string {
  const resources: Record<string, any> = {};
  
  graph.nodes.forEach(node => {
    switch (node.type) {
      case 'vpc':
        resources[node.id] = {
          Type: 'AWS::EC2::VPC',
          Properties: {
            CidrBlock: node.properties.cidr || '10.0.0.0/16',
            EnableDnsHostnames: true,
            EnableDnsSupport: true,
            Tags: [{ Key: 'Name', Value: node.label }],
          },
        };
        break;
      case 'subnet':
        resources[node.id] = {
          Type: 'AWS::EC2::Subnet',
          Properties: {
            VpcId: { Ref: graph.nodes.find(n => n.type === 'vpc')?.id || 'VPC' },
            CidrBlock: node.properties.cidr || '10.0.1.0/24',
            MapPublicIpOnLaunch: node.properties.isPublic !== false,
            Tags: [{ Key: 'Name', Value: node.label }],
          },
        };
        break;
      case 'ec2':
        resources[node.id] = {
          Type: 'AWS::EC2::Instance',
          Properties: {
            InstanceType: node.properties.instanceType || 't3.micro',
            ImageId: 'ami-0c55b159cbfafe1f0',
            Tags: [{ Key: 'Name', Value: node.label }],
          },
        };
        break;
      case 'rds':
        resources[node.id] = {
          Type: 'AWS::RDS::DBInstance',
          Properties: {
            DBInstanceClass: node.properties.instanceType || 'db.t3.micro',
            Engine: 'postgres',
            MasterUsername: 'admin',
            MasterUserPassword: { Ref: 'DBPassword' },
            StorageEncrypted: node.properties.encrypted !== false,
          },
        };
        break;
      case 's3':
        resources[node.id] = {
          Type: 'AWS::S3::Bucket',
          Properties: {
            BucketName: `${node.id}-bucket`,
            BucketEncryption: {
              ServerSideEncryptionConfiguration: [{
                ServerSideEncryptionByDefault: { SSEAlgorithm: 'AES256' },
              }],
            },
          },
        };
        break;
    }
  });

  const template = {
    AWSTemplateFormatVersion: '2010-09-09',
    Description: `${graph.metadata.name} - Generated by InfraVizAI`,
    Parameters: {
      DBPassword: {
        Type: 'String',
        NoEcho: true,
        Description: 'Database password',
      },
    },
    Resources: resources,
  };

  return JSON.stringify(template, null, 2);
}

// Pulumi generation (TypeScript)
function generatePulumi(graph: InfraGraph): string {
  const lines: string[] = [
    '// Generated by InfraVizAI',
    `// Infrastructure: ${graph.metadata.name}`,
    '',
    'import * as pulumi from "@pulumi/pulumi";',
    'import * as aws from "@pulumi/aws";',
    '',
  ];

  graph.nodes.forEach(node => {
    switch (node.type) {
      case 'vpc':
        lines.push(
          `const ${node.id} = new aws.ec2.Vpc("${node.id}", {`,
          `  cidrBlock: "${node.properties.cidr || '10.0.0.0/16'}",`,
          '  enableDnsHostnames: true,',
          '  enableDnsSupport: true,',
          '  tags: {',
          `    Name: "${node.label}",`,
          '  },',
          '});',
          ''
        );
        break;
      case 'ec2':
        lines.push(
          `const ${node.id} = new aws.ec2.Instance("${node.id}", {`,
          `  instanceType: "${node.properties.instanceType || 't3.micro'}",`,
          '  ami: "ami-0c55b159cbfafe1f0",',
          '  tags: {',
          `    Name: "${node.label}",`,
          '  },',
          '});',
          ''
        );
        break;
      case 'rds':
        lines.push(
          `const ${node.id} = new aws.rds.Instance("${node.id}", {`,
          `  instanceClass: "${node.properties.instanceType || 'db.t3.micro'}",`,
          '  engine: "postgres",',
          '  username: "admin",',
          '  password: pulumi.secret("CHANGE_ME"),',
          `  storageEncrypted: ${node.properties.encrypted !== false},`,
          '});',
          ''
        );
        break;
      case 's3':
        lines.push(
          `const ${node.id} = new aws.s3.Bucket("${node.id}", {`,
          '  serverSideEncryptionConfiguration: {',
          '    rule: {',
          '      applyServerSideEncryptionByDefault: {',
          '        sseAlgorithm: "AES256",',
          '      },',
          '    },',
          '  },',
          '});',
          ''
        );
        break;
    }
  });

  lines.push(
    '// Export outputs',
    `export const region = "${graph.metadata.region}";`
  );

  return lines.join('\n');
}

export function generateIaC(graph: InfraGraph, framework: IaCFramework): string {
  switch (framework) {
    case 'terraform':
      return generateTerraform(graph);
    case 'cloudformation':
      return generateCloudFormation(graph);
    case 'pulumi':
      return generatePulumi(graph);
    default:
      return generateTerraform(graph);
  }
}
